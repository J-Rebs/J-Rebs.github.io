---
layout: post
title: Week 3-4
---
What is a function? *F(x) = 2x* is a function. Smartphones have a timer ‘function’. People sometimes refer to functionality to mean useful ability to do something. The second two things listed seem related, but the first item *F(x) = 2x* seems pretty different from the others. However, I would argue it’s not. I am not a mathematician in any way, but I do like studying some of it. One of the most useful takeaways I have from the math courses I have taken is that a function is not about converting one number into another, but rather it is about giving a set of instructions tying a start point to exactly one end point. 

To rephrase the above in math, “a function from a [set](https://en.wikipedia.org/wiki/Set_(mathematics)) X to a set Y assigns to each element of X exactly one element of Y” (see [Wikipedia](https://en.wikipedia.org/wiki/Function_(mathematics))). The usefulness of a function comes from the fact that it can tell us for some set of start points, we know where each of those start points leads. It’s not a perfect analogy, but you can think of a single function then like a sign at the fork in a road, telling you where you will end up if you take a given path. Then if we chain together a bunch of functions, we start building a map of sorts (a [computational graph](https://www.tutorialspoint.com/python_deep_learning/python_deep_learning_computational_graphs.htm)) that we can use to navigate from one point to another far way. 

That’s kind of what DBT does but with SQL files as part of the Extract, transform, load ([ETL](https://en.wikipedia.org/wiki/Extract,_transform,_load)) process where data goes from raw source to stored outputs for use. We can think of Extraction as getting the starting points in our computational graph and the Loading step as arriving out our end points. The Transformation step is the paths we have to follow from start points to end points. DBT handles the Transformation step allowing a person to look at each step in the path as its own SQL model. Each model can refer to other models, so DBT can construct a graph ensuring you do the first step, then the second step, and so on. Like mentioned in the week 2 blog, this helps make big problems into smaller problems allowing you to focus on each individual model without worrying about losing track of what order to do the models.

In our project, we use DBT to help compute data used for index insurance (see [About My Project](https://j-rebs.github.io/#about-my-project)). The results from running models in DBT are then displayed on a webpage. Collectively, the data visualization front end along with a Python server and the DBT models in the back end create a single index insurance app. There are some other details in terms of the database DBT writes to and reads from along with how we call DBT that may change, so I won’t go into those as much here. 

Each app is done by country. When I started this summer, we already had models developed for one country’s app (Zambia), but we needed to translate those models for a new country (Ethiopia). This process is not unlike planning for a trip where you review the route of the trip, look for points of concern, and consult others with expertise about how to resolve those concerns. 

For the Ethiopia app, we studied the Zambia models then worked with the FIST team to understand how the Ethiopia models would need to change conceptually. We then implemented changes to the models, tested them in DBT, and checked on questions and the reasonableness of outputs with the FIST team using [GitHub Issues](https://github.com/features/issues). Our objective was not to build in every piece of functionality to the models on the first go, but rather to develop some working models we could hook into a front end. The idea is to make sure everything functions end to end and then add in detail later. With this approach, we completed the first go at the Ethiopia DBT models. 

 

